/*******************************************************************************
 * Copyright (c) 2014 itemis AG (http://www.itemis.de).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.franca.examples.deploy.generators

import org.example.spec.BinaryProtocol
import org.franca.deploymodel.core.FDeployedInterface
import org.franca.core.franca.FInterface
import org.franca.core.franca.FStructType

import org.franca.core.franca.FField
import org.franca.core.franca.FTypeRef
import org.franca.core.franca.FBasicTypeId

import static extension org.franca.core.FrancaModelExtensions.*
import static extension org.franca.core.framework.FrancaHelpers.*

/**
 * This is an example code generator for generating C structs from
 * Franca struct definitions. The generators needs input files which
 * are deployment definitions according to deployment specification
 * BinaryProtocol.fdepl.
 */
class ExampleBinaryProtocolGenerator {

	/**
	 * An instance of the ProviderPropertyAccessor for BinaryProtocol-models
	 * (it has been generated automatically from BinaryProtocol.fdepl).
	 */
	BinaryProtocol.InterfacePropertyAccessor deploy

	/*
	 * This function is called from outside and generates code from a 
	 * Franca interface definition and deployment information attached to it.
	 * The FDeployedInterface instance is a wrapper which is used to 
	 * instantiate a BinaryProtocolInterfacePropertyAccessor.
	 * This InterfacePropertyAccessor object will be used to read the
	 * deployment information attached to the Franca interface.
	 */
	def generateProtocol (FDeployedInterface deployed) {
		deploy = new BinaryProtocol.InterfacePropertyAccessor(deployed)
		generateProtocol(deployed.FInterface)	
	} 
	

	/*
	 * This function is the (internal) entry point for generating
	 * code from a Franca interface specification. It uses the basic
	 * FInterface object as starting point; however, during code 
	 * generation it will access the deployment information via the
	 * "deploy" member.
	 */
	def private generateProtocol (FInterface api) '''
		#ifndef __«api.name.toUpperCase»_h__
		#define __«api.name.toUpperCase»_h__
		«api.generateHeader»
		
		// generate one struct per protocol message
		«FOR s : api.types.filter(typeof(FStructType))»
		struct {
			«FOR e : s.allElements.filter(typeof(FField))»
			«e.type.generateType» «e.name»«e.generateBitSpecifier»;
			«ENDFOR»
		} «s.name.toFirstUpper»;
		
		«ENDFOR»
		
		#endif
	'''
		
	/** Get number of bits from deployment model (if available) */
	def private generateBitSpecifier (FField f) {
		if (deploy.getNumberOfBits(f)==null) {
			""
		} else {
			" : " + deploy.getNumberOfBits(f)
		}
	}

	def private generateHeader (FInterface api) '''
		/**
		 * This is a generated file for interface «api.name».
		 * Generated by Franca-based example BinaryProtocol generator version 0.9.0.
		 *
		 * NOTE: This code is by far not complete - it is used as an example for
		 *       code generation based on Franca IDL using Xtend (see xtend-lang.org).
		 */
	'''

	def private generateType (FTypeRef tr) {
		val p = tr.actualPredefined
		if (p!=null && p!=FBasicTypeId::UNDEFINED) {
			switch (p) {
				case FBasicTypeId::INT8        : "char"
				case FBasicTypeId::INT16       : "short"
				case FBasicTypeId::INT32       : "int"
				case FBasicTypeId::UINT8       : "unsigned char"
				case FBasicTypeId::UINT16      : "unsigned short"
				case FBasicTypeId::UINT32      : "unsigned int"
				case FBasicTypeId::BYTE_BUFFER : "char[]"
				default                   : "/*" + tr.predefined.toString + "*/"  // TODO
			}
		} else {
			val i = tr.actualInterval
			if (i!=null) {
				if (i.lowerBound==null || i.lowerBound.signum < 0)
					"int"
				else
					"unsigned int"
			} else {
				tr.actualDerived.name
			}
		}
	}


}