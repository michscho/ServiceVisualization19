/*******************************************************************************
* Copyright (c) 2012 Harman International (http://www.harman.com).
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
package org.franca.generators.html

import java.util.Set
import org.franca.core.franca.FAnnotationType
import org.franca.core.franca.FArgument
import org.franca.core.franca.FArrayType
import org.franca.core.franca.FBroadcast
import org.franca.core.franca.FCompoundType
import org.franca.core.franca.FEnumerationType
import org.franca.core.franca.FInterface
import org.franca.core.franca.FMapType
import org.franca.core.franca.FMethod
import org.franca.core.franca.FModel
import org.franca.core.franca.FModelElement
import org.franca.core.franca.FStructType
import org.franca.core.franca.FType
import org.franca.core.franca.FTypeDef
import org.franca.core.franca.FTypeRef
import org.franca.core.franca.FUnionType
import org.franca.core.utils.ExpressionEvaluator

class HTMLGenerator {
	
	Set<FType> usedTypes = newHashSet()
	
	def generate (FModel model) '''
		<body>
		<h1>Franca IDL package: «model.name»</h1>
		«FOR i : model.interfaces»
			«i.generate»
		«ENDFOR»
		<br><hr>
		<em>Generated by Franca.HTMLGenerator</em>
		</body>
	'''

	def generate (FInterface api) '''
	
		<h2>Interface «api.name»</h2>

		«IF api.version!==null»
			<h3>Version «api.version.major».«api.version.minor»</h3>
		«ENDIF»
		«api.genComment(true)»

		«IF ! api.attributes.empty»
			<h3>Attributes</h3>
			<table border=1>
			<tr><th>Type</th><th>Name</th><th>Comment</th></tr>
			«FOR a : api.attributes»
				<tr><td>«a.type.labelLinked»</td><td><b>«a.name»</b></td><td>«a.genComment(false)»</td></tr>
			«ENDFOR»
			</table>
		«ENDIF»

		«IF ! api.methods.empty»
			<h3>Methods</h3>
			«FOR m : api.methods»
				<h4>«m.name»()</h4>
				«m.genComment(true)»
				«m.generate»
			«ENDFOR»
		«ENDIF»

		«IF ! api.broadcasts.empty»
			<h3>Broadcasts</h3>
			«FOR b : api.broadcasts»
				<h4>«b.name»()</h4>
				«b.genComment(true)»
				«b.generate»
			«ENDFOR»
		«ENDIF»

		«IF ! api.types.empty»
			<h3>Types</h3>
			«api.types.generate»
		«ENDIF»

		«var externalTypes = usedTypes.filter(t | ! api.types.contains(t))»
		«IF ! externalTypes.empty»
			<h3>External types</h3>
			«externalTypes.generate»
		«ENDIF»
	'''
	
	def generate (FMethod api) '''
		<table border=1>
		<tr><th>Dir</th><th>Type</th><th>Name</th><th>Comment</th></tr>
		«api.inArgs.generate("in")»
		«api.outArgs.generate("out")»
		«IF api.errorEnum!==null»
			<tr><td>error</td><td>«api.errorEnum.labelLinked»</td><td></td><td></td></tr>
		«ENDIF»
		«IF api.errors!==null»
			«IF api.errors.base !== null»
				<tr><td>error</td><td>«api.errors.base.genExtends»</td><td></td><td></td></tr>
			«ENDIF»
			«FOR e : api.errors.enumerators»
				<tr><td>error</td><td></td>
				<td>«e.name»«IF e.value!==null» = «ExpressionEvaluator::evaluateIntegerOrParseString(e.value)»«ENDIF»</td>
				<td>«e.genComment(false)»</td></tr>
			«ENDFOR»
		«ENDIF»
		</table>
	'''
	
	def generate (FBroadcast api) '''
		<table border=1>
		<tr><th>Dir</th><th>Type</th><th>Name</th><th>Comment</th></tr>
		«api.outArgs.generate("out")»
		</table>
	'''
	
	def generate (Iterable<FArgument> args, String tag) '''
		«FOR a : args»
			<tr><td>«tag»</td><td>«a.type.labelLinked»</td><td>«a.name»</td><td>«a.genComment(false)»</td></tr>
		«ENDFOR»
	'''

	
	def generate (Iterable<FType> types) '''
		<table border=1>
		<tr><th>Type name</th><th>Comment</th><th>Definition</th></tr>
		«FOR t : types.sortBy [name]»
			<tr>
				<td><a name="type_«t.name»">«t.name»</a>«t.genBase»</td>
				<td>«t.genComment(false)»</td>
				<td>«t.generateDefinition»</td>
			</tr>
		«ENDFOR»
		</table>
	'''	
	
	/** Generate "extends ...", iff FType has a base class */
	def genBase (FType t) {
		switch (t) {
			FStructType: genExtends(t.base)
			FUnionType: genExtends(t.base)
			FEnumerationType: genExtends(t.base)
			default: ""
		}
	}
	
	def genExtends (FType base) {
		if (base !== null) {
			" extends " + base.labelLinked
		} else {
			""
		}
	}
	
	
	def dispatch generateDefinition (FArrayType type) '''
		Array of «type.elementType.labelLinked»
	'''
	
	def dispatch generateDefinition (FCompoundType type) '''
		<table border=1>
			«FOR t : type.elements.sortBy [name]»
				<tr>
					<td>«t.name»</td>
					<td>«t.type.labelLinked»</td>
					<td>«t.genComment(false)»</td>
				</tr>
			«ENDFOR»
		</table>
	'''

	def dispatch generateDefinition (FEnumerationType type) '''
		<table border=1>
			«FOR e : type.enumerators»
				<tr>
					<td>«e.name»</td>
					<td>«IF e.value!==null»«ExpressionEvaluator::evaluateIntegerOrParseString(e.value)»«ENDIF»</td>
					<td>«e.genComment(false)»</td>
				</tr>
			«ENDFOR»
		</table>
	'''

	def dispatch generateDefinition (FMapType type) '''
		Map «type.keyType.labelLinked» to «type.valueType.labelLinked»
	'''

	def dispatch generateDefinition (FTypeDef type) '''
		«type.actualType.labelLinked»
	'''

	def dispatch generateDefinition (FType type) ''''''



	def getLabel (FTypeRef type) {
		if (type.derived!==null)
			type.derived.name
		else
			type.predefined.toString
	}
	
	def getLabelLinked (FTypeRef type) {
		if (type.derived!==null) {
			type.derived.labelLinked
		} else
			type.predefined.toString
	}

	def getLabelLinked (FType type) {
		usedTypes.add(type)
		'<a href="#type_' + type.name + '">' + type.name + '</a>'
	}

	
	def private genComment (FModelElement it, boolean paragraph) {
		if (comment!==null && (! comment.elements.empty)) {
			var t = ''
			if (paragraph)
				t = t + '<p>'
			if (comment.elements.size==1) {
				// if only one annotation, we are rendering without <table>
				var e = comment.elements.get(0)
				// skip annotation type @descrption for convenience
				if (e.type!=FAnnotationType::DESCRIPTION) {
					t = t + '<b>' + e.type.literal + '</b>' + ' : '
				}
				t = t + '<em>' + abbrevCommentString(e.type, e.comment) + '</em>' 				
			} else {
				// if more than one annotation, we are rendering with a <table>
				t = t + '<table border=1>'
				for(e : comment.elements) {
					var comment = abbrevCommentString(e.type, e.comment)
					if (e.type==FAnnotationType::DESCRIPTION)
						// skip annotation type @description for convenience
						t = t + '<tr><td colspan=2><em>' + comment + '</em></td></tr>'
					else
						t = t + '<tr><td><b>' + e.type.literal + '</b></td><td><em>' + comment + '</em></td></tr>'
				}
				t = t + '</table>'
			}
			if (paragraph)
				t = t + '</p>'
			return t
		} else {
			''
		}
	}
	
	def private abbrevCommentString (FAnnotationType type, String comment) {
		if (type==FAnnotationType::SOURCE_URI) {
			var abbr = comment
			if (abbr.length>20) {
				abbr = abbr.substring(0,9) + "..." + abbr.substring(abbr.length-10)
			}
			abbr				
		} else {
			comment 				
		}
	}
}
