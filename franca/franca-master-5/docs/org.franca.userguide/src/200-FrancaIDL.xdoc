chapter:FrancaIDL[Franca IDL Reference]

The core of Franca IDL is the support for ref:FIDL_Interface[interface definitions], consisting of
attributes, methods and broadcasts. Those definitions will be based on a ref:FIDL_Types[type system],
which provides a variety of primitive and user-defined types as well as constant definitions. 
Additionally, the dynamic behavior of interfaces can be specified using ref:FIDL_Contracts[contracts]
consisting of protocol state machines.
Types and constants can be defined either on a global scope using
ref:FIDL_TypeCollection[type collections], or as part of an
ref:FIDL_Interface[interface definition].
Finally, Franca IDL supports Java-doc like tagged comments, called ref:FIDL_Comments[structured comments]
and language features like e[packages] and e[imports] which can be used for defining interfaces using
ref:FIDL_MultipleFiles[multiple Franca IDL files].


section:FIDL_Types[Data types]

Franca supports a predefined set of primitive data types and a variety of user-defined types.
User-defined types may be arrays, type aliases, structures, unions, enumerations or maps.
User-defined types can refer to primitive types or other, previously defined types. 

section2:FIDL_PrimitiveTypes[Primitive types]

The primitive types supported by Franca are listed in ref:PrimitiveTypes[the following table].
There is a number of very specific signed and unsigned integer types with varying ranges.
This allows to be very specific about the size of these types on any target platform.
Additionally, Franca IDL provides a way to specify generic integer types with optional
min/max range (since Franca 0.9.0, see next section). 

table:PrimitiveTypes[
	caption[Primitive types of Franca IDL.]
	tf[
		professional
		tcol[1] tcol[7]
	]
	tr[
		td[e[Type name]]
		td[e[Description]]
		---
	]
	tr[
		td[code[Franca][UInt8]]
		td[unsigned 8-bit integer (range 0..255)]
	]
	tr[
		td[code[Franca][Int8]]
		td[signed 8-bit integer (range -128..127)]
	]
	tr[
		td[code[Franca][UInt16]]
		td[unsigned 16-bit integer (range 0..65535)]
	]
	tr[
		td[code[Franca][Int16]]
		td[signed 16-bit integer (range -32768..32767)]
	]
	tr[
		td[code[Franca][UInt32]]
		td[unsigned 32-bit integer (range 0..4294967295)]
	]
	tr[
		td[code[Franca][Int32]]
		td[signed 32-bit integer (range -2147483648..2147483647)]
	]
	tr[
		td[code[Franca][UInt64]]
		td[unsigned 64-bit integer]
	]
	tr[
		td[code[Franca][Int64]]
		td[signed 64-bit integer]
	]
	tr[
		td[code[Franca][Integer]]
		td[generic integer (with optional range definition, see below)]
	]
	tr[
		td[code[Franca][Boolean]]
		td[boolean value, which can take one of two values: false or true.]
	]
	tr[
		td[code[Franca][Float]]
		td[floating point number (4 bytes, range +/- 3.4e +/- 38, ~7 digits)]
	]
	tr[
		td[code[Franca][Double]]
		td[double precision floating point number (8 bytes, range +/- 1.7e +/- 308, ~15 digits)]
	]
	tr[
		td[code[Franca][String]]
		td[character string, see caveat below]
	]
	tr[
		td[code[Franca][ByteBuffer]]
		td[buffer of bytes (aka BLOB), see caveat below]
	]
]

Caveat: APIs should use arguments of type code[Franca][String] or
code[Franca][ByteBuffer] only for transporting payload data which is
not parsed by the server component which offers the interface.
A useful example for code[Franca][ByteBuffer] arguments is a 
protocol layer which examines the header of an incoming data
package, but doesn't look at the payload data.
If the server does e[deep packet inspection] or similar on the
incoming data, the argument is used as a tunnel for a protocol
which is not specified by the API. This bypass of the API definition
weakens the API abstraction and will inevitably lead to integration
issues and runtime problems.

The actual physical encoding of the primitive types depends on the target language.
A default encoding will be defined as part of Franca's deployment model. 
Exceptions from this default encoding can be defined in the target-language-specific
deployment model.


section2:FIDL_RangedInteger[Integer with optional range]

The primitive integer types with fixed number of bits as defined above
(e.g., code[Franca][UInt32]) allow to specify interfaces with the actual 
implementation in mind. This is typically preferred by embedded systems
developers, in order to exactly know which data is being transported.
However, there are some drawbacks of using these integer types for
interface definitions. The specific implementation platform might
not support all of these types, e.g., Java doesn't support unsigned integers.

Since Franca 0.9.0, the IDL supports a generic integer type named e[Integer].
In order to restrict the range of actual values which can be used, Franca IDL
allows to specify a range of values this type can assume. Examples:

code[Franca][
Integer
Integer(1,7)
Integer(-20,100)
Integer(0,maxInt)
Integer(minInt,maxInt)
] 

The range is given as a minimum and a maximum value.
The min/max values might be negative, but the minimum value always has to
be less then or equal to the maximum value.
If no range is given, the biggest available integer type for the
specific platform should be used.
There are special keywords code[Franca][minInt] and code[Franca][maxInt],
which represent the smallest and biggest integer on the specific platform, respectively.

Note that by using the code[Franca][Integer] type it is possible to emulate all
primitive integer types as defined above. Similarly, it is possible to replace
usages of the ranged integer type by the next bigger primitive integer type given
that all restrictions of the specific implementation platform are known.
There is a helper model transformation in the Franca framework which supports
these two type conversions,
see section ref:FrancaModelUtils_IntegerTypeConverter[IntegerTypeConverter]. 


section2:FIDL_Types_Array[Arrays]

There are two ways of defining array types: explicitly named arrays or implicit
array types without a name.

Explicitly named, one-dimensional arrays can be defined by 
code[Franca][
array ExampleArray of UInt8
] 

The array's element type can be any primitive or user-defined type, including another array.
This can be used to define multi-dimensional arrays:
code[Franca][
array ExampleArrayRow of UInt8
array ExampleArray of ExampleArrayRow
] 

Implicit ("inline") array types are defined by attaching square brackets (e.g., code[Franca][UInt8\[\]])
to any other type definition. This can be done for attributes, struct members and
arguments of methods and broadcasts. See more examples below. Note: Inline arrays can only be defined
one-dimensional. If multi-dimensional arrays are needed, only one dimension can be defined as unnamed
array. 

The syntax for defining implicit array types doesn't support specifying fixed array sizes or
array size limits. If you want to define such properties for arrays, you might use Franca's
ref:FrancaConcepts_DeploymentModels[deployment model] feature.
 


section2:FIDL_Types_Enum[Enumerations]

section3:FIDL_Types_Enum_Basic[Basic enumerations]

An e[enumeration] (also called e[enumerated type]) is a data type consisting of a set
of named values called e[enumerators]. In Franca IDL, an enumeration is defined by
code[Franca][
enumeration ExampleEnumeration1 {
	VALUE_1
	VALUE_2
	VALUE_3
	// ...
}
]

The enumerators are identifiers which can be used as unique constants.
Values for the enumerators can be defined optionally.
Each value is defined using an ref:FIDL_Expressions[expression] of type e[integer]:
code[Franca][
enumeration ExampleEnumeration2 {
	VALUE_1 = 100
	VALUE_2 = 100+1
	VALUE_3 = 30*30
	// ...
}
]

As the enumerator value can be any expression of type e[integer],
it is also possible to specify it with a hexadecimal or binary literal:
code[Franca][
enumeration ExampleEnumeration2b {
	VALUE_1 = 0xBADA
	VALUE_2 = 0X89ab
	VALUE_3 = 0b0001001
	VALUE_4 = 0B10101
	// ...
}
]

Deprecated:
It is also possible to use string constants as enumerator value definitions.
However, this will result in a deprecated-warning by the Franca validator. 
Note that in this case the string constant should be parsable as integer number:
code[Franca][
enumeration ExampleEnumeration3 {
	E1 = "10"
	E2 = "20"
	E3 = "foo"  // invalid, no integer
	// ...
}
]

section3:FIDL_Types_Enum_Inheritance[Enumeration inheritance]

Enumeration types support e[inheritance] by using the keyword e[extends].
This allows to derive a new enumeration type from an existing one and add
further enumerators to the base enumeration. Only single inheritance is allowed for
each enumeration - however, a chain or tree of enumerations can be build. Example:
code[Franca][
enumeration BaseEnumeration {
	VALUE_1
	VALUE_2
}

enumeration DerivedEnumeration extends BaseEnumeration {
	VALUE_3
	VALUE_4
}
]

If the target language doesn't support inheritance for enumeration types, the e[extends]-chain
will be transformed into a flat enumeration consisting of all enumerators of the base type(s)
and those of the derived type.
 

section2:FIDL_Types_Struct[Structures]

A e[struct] (also called e[record], e[tuple], or e[compound data]) is a value that contains
other values, typically in fixed number and sequence and typically indexed by names.
The elements of structs are usually called e[fields] or e[members] (source: Wikipedia).

section3:FIDL_Types_Struct_Basic[Basic structs]

User-defined structures can be defined by specifying the structure's members, with a type
and name for each member: 
code[Franca][
struct ExampleStruct {
	UInt8 member1
	String member2
	ExampleArray member3
	UInt16\[\] member4
}
]
Element types might be predefined types or user-defined types. This allows e.g. nested structures or
arrays of structures. Element types may also be arrays, e.g., e[member4] is an unnamed array of type
code[Franca][UInt16].

Note that the struct type definition also defines the order of the elements. Thus, the following two
struct definitions are e[different]: 
code[Franca][
struct ExampleStruct1 {
	UInt8 member1
	String member2
}

struct ExampleStruct1 {
	String member2
	UInt8 member1
}
]

Any communication implementation should respect the element order given by the Franca IDL type definition.
This is relevant only for usecases where an implicit agreement on the element order is required.
E.g., for binary serialization and deserialization the element names will not be part of the serialized message.
Thus, sender and receiver of a message have to agree on the element order.
In other contexts this might not be relevant, e.g., when using a JSON-style serialization or for Franca IDL
ref:FIDL_Constants_Complex[struct initializer expressions].

However, as it is not known at interface definition time in which context the interface will be used,
the interface designer has to take the element order into account. 

section3:FIDL_Types_Struct_Inheritance[Struct inheritance]

Struct types support e[inheritance] by using the keyword e[extends].
This allows to derive a new structure type from an existing one and add
further structure members to the base's members. Only single inheritance is allowed for
each structure definition - however, a chain or tree of structures can be build. Example:
code[Franca][
struct BaseStruct {
	UInt8 member1
	ExampleArray member2
}

struct DerivedStruct extends BaseStruct {
	ExampleArray member3
}
]

If the target language doesn't support inheritance for structure types, the e[extends]-chain
will be transformed into a flat structure consisting of all members of the base
type(s) and those of the derived type.

section3:FIDL_Types_Struct_Polymorphic[Polymorphic structs]

The root type in a struct inheritance hierarchy may be marked with the 
e[polymorphic]-keyword. Consider the following example:
code[Franca][
method callme {
	in {
		BaseStruct t
	}
}

struct BaseStruct polymorphic {
	Int16 a
}

struct Derived1 extends BaseStruct {
	Int16 b
}
	
struct Derived2 extends BaseStruct {
	String c
}
]

The caller of method e[callme] might provide an argument of type e[Derived1],
although the method's argument type is declared as type e[BaseStruct].
In an environment where polymorphism is fully supported, the server will then
be able to receive an object of the actual type, i.e., e[Derived1].
It will be able to access the struct element e[b].

However, as full polymorphism support usually requires some implementation
overhead in the IPC target platform, this behavior has to be explicitly switched
on by flagging the root of the struct inheritance hierarchy with the
keyword e[polymorphic]. Without setting the root struct type to e[polymorphic],
the server-side implementation of the interface will only be able to access the
actual type used in the interface definition (and not derived types). 
This low-footprint behavior is the default.


section2:FIDL_Types_Union[Unions (aka variants)]

A e[union] is a value that may have any of several representations or formats;
or a data structure that consists of a variable which may hold such a value (source: Wikipedia).

section3:FIDL_Types_Union_Basic[Basic unions]

Unions can be defined by specifying its possible value types, together with a name for
each representation. As a union will have only one representation at a time, the order of
the union's elements is not important. Example of a union definition: 
code[Franca][
union ExampleUnion {
	UInt32 element1
	Float element2
}
]
Element types might be predefined types or user-defined types.
This allows e.g. nested unions, or unions of structures.
No two elements of an union may have the same type. 

section3:FIDL_Types_Union_Inheritance[Union inheritance]

Union types support e[inheritance] by using the keyword e[extends].
This allows to derive a new union type from an existing one and add
further elements to the base union. Only single inheritance is allowed for
each union definition - however, a chain or tree of unions can be build. Example:
code[Franca][
union BaseUnion {
	UInt32 genericRepresentation
}

union DerivedUnion extends BaseUnion {
	Float aFloat
	String aString
}
]

If the target language doesn't support inheritance for union types, the e[extends]-chain
will be transformed into a flat union consisting of all elements of the base
type(s) and those of the derived type.


section2:FIDL_Types_Map[Maps (aka dictionaries)]

Maps represent key/value-stores and are typically implemented by B-trees or hashes.
The definition for Maps with Franca IDL specifies the key type and the value type.
Example:
code[Franca][
map ExampleMap {
	Int16 to ExampleStruct
}
]

Key types as well as value types might be primitive or user-defined types
which provide an equality-relation. 
NB: In some target languages, key types might be restricted to primitive types.


section2:FIDL_Types_TypeDef[Type definitions (aka aliases)]

Type definitions can be used to create new type names which are simple aliases for
existing primitive or user-defined types. Example:
code[Franca][
typedef ExampleAlias is UInt32
]


section:FIDL_Constants[Constant definitions]

Franca supports the definition of constants, which are typed values
identifiable by a unique name. Constants might be used as part
of any ref:FIDL_Expressions[expression], given that they have a compatible type.
Tools as code generators should create code which establishes these constants
on the executable platform.

section2:FIDL_Constants_Primitive[Primitive constants]

Here are some examples of primitive constants: 
code[Franca][
const Boolean b1 = true
const UInt32 MAX_COUNT = 10000
const UInt16 SOME_ID = 0xA00B
const UInt8 BYTE_ME = 0b00110011
const String foo = "bar"
const Double pi = 3.1415d
]

The initializer expression on the right-hand side of the constant definition
must evaluate to a proper type which is compatible with the constant's type.
Note that ref:FIDL_Expressions[complex expressions] might be used as initializer
expressions. Examples:
code[Franca][
const UInt32 twentyfive = 5*5
const Boolean b2 = MAX_COUNT > 3
const Boolean b3 = (a && b) || foo=="bar"
]

section2:FIDL_Constants_Complex[Complex constants]

Constants may also have more complex, user-defined types. This will lead to more
elaborate initializer expressions. This section will show examples of how to define
constants which are of array, struct, union and map type.

For array constants, the initializer expression lists the array elements
in square brackets. Example:
code[Franca][
array Array1 of UInt16

const Array1 empty = \[\]
const Array1 full  = \[ 1, 2, 2+3, 100*100+100 \]
]

Constants of struct type will have to define an initializer expression for each
struct element. Example:
code[Franca][
struct Struct1 {
	Boolean e1
	UInt16 e2
	String e3
}

const Struct1 s1 = { e1: true, e2: 1, e3: "foo" }
]

If struct types are getting more complex (i.e., with nested struct types or arrays),
the initializer expression is not easy to understand. Therefore, each struct
element in the initializer expression has to be uniquely identified by the
element name (e.g., code[e1] in the example).
Note that explicitly naming the elements in the struct initializer allows
to initialize the elements in any order. Each element has to occur exactly once.

The syntax for union type constants is similar to struct types. However,
as a union represents exactly one of its elements, the initializer expression
will only refer to one element name. Some examples:
code[Franca][
union Union1 {
	UInt16 e1
	Boolean e2
	String e3
}

const Union1 uni1 = { e1: 1 }
const Union1 uni2 = { e3: "foo" }
]

Finally, the initializers for a constant of type e[map] contains a list of
key/value pairs. Example:
code[Franca][
map Map1 { UInt16 to String }

const Map1 m1 = \[ 1 => "one", 2 => "two" \]
]

The initializer expressions for the keys and values of each pair might be 
themselves arbitrary complex expression. However, they have to be evaluated
to the proper type given by the definition of the map type.
 

section:FIDL_Expressions[Expressions]

Expressions can be used in Franca IDL in various ways:

ul[
	item[as default values for ref:FIDL_Types_Enum_Basic[enumerators]]
	item[as initializer expressions for constant definitions]
	item[as guard conditions in ref:FIDL_Contracts_PSM[interface contracts]]
	item[as initializer expressions for ref:FIDL_Contracts_StateVars[state variables] in contracts]
	item[in the ref:FIDL_Contracts_Actions[action code] of contracts (e.g., in if-conditions)]
]

section2:FIDL_Expressions_TypeSystem[Type system]

Expressions in Franca IDL are e[typed]. The type system supports the
basic types e[boolean], e[integer], e[float], e[double] and e[string].
The type system is aware of user-defined types defined in Franca IDL.
I.e., if a struct type is defined by 

code[Franca][
struct SomeStruct {
	UInt8 member1
	String member2
}
]

then the type e[SomeStruct] is also available in expressions.
E.g., if expression code[s] refers to a Franca constant of type
e[SomeStruct], the expression code[s->member1] will be of type e[integer].

The Franca validator ensures that all expressions have a proper type
which also has to be consistent with the usage of the expression.
E.g., an expression used as a guard condition in a contract must
be of e[boolean] type.    

section3:FIDL_Expressions_TypeSystem_Rules[Type system rules]

Note that in order to reduce specification errors the Franca IDL type system
provides only a minimum of implicit type conversions (aka typecasts).
In particular, the following rules apply:

ul[
	item[There is no implicit conversion from integer to float or vice versa.]
	item[There is no implicit conversion from integer to double or vice versa.]
	item[There is an implicit conversion from float to double and vice versa.]
	item[There is no implicit conversion from enumeration types to integer.]
	item[For struct and union type inheritance:
		There is an implicit upcast for derived struct (and union) types.
		There is no downcast for struct and union types.
	]
	item[For enumeration types: There is an implicit downcast for enumeration types
		 (i.e., an enumerator from a base enumeration can be used as representant of
		 any derived enumeration).
		 Thus, for enumerations, inheritance is not specialization, but generalization.
		]
	item[The code[Franca][typedef] mechanism is transparent for the type system
		(i.e., types introduced by code[Franca][typedef] will be handled
		identically to their base types).
	]
]  

section2:FIDL_Expressions_Constants[Constant values]

The basic elements for building expressions are e[constant values].

code[Franca][
// constant expressions
true      // boolean
false     // boolean
100       // integer (positive)
-273      // integer (negative)
0x0ABC    // integer (hexadecimal)
0b010101  // integer (binary)
1.2f      // float
6.022e23f // float
3.1415d   // double
8.617e-5d // double
"foobar"  // string
]

section2:FIDL_Expressions_ComparisonOps[Comparison operators]

Two expressions of equal type may be related to each other using
comparison operators. The resulting expression is of type e[boolean].

todo[Examples for all comparison operators will be given here.]


section2:FIDL_Expressions_ArithmeticOps[Arithmetic operations]

Expressions may be built from sub-expressions of type e[integer],
e[float] or e[double] using arithmetic operations.

todo[Examples for all arithmetic operators will be given here.]


section2:FIDL_Expressions_BooleanOps[Boolean operations]

Expressions may be built from sub-expressions of type e[boolean]
using boolean operations.

todo[Examples for all boolean operators will be given here.]


section:FIDL_TypeCollection[TypeCollection definition]

A e[type collection] is a (maybe empty) set of user-defined types and constant definitions.
Previous to Franca-0.8.0, user-defined types could be located on the
top-level of a Franca model. This has been banned with Franca-0.8.0 in order to 
provide a consistent scheme of fully qualified names and versioning for
user-defined types. Type collections may also define constants.

Each type collection in Franca has some metadata: a single identifier
e[name] for the collection and an optional e[version number] (with major/minor scheme).
The name of the type collection will be scoped relative to the fully qualified name
of the package defined at the beginning of the Franca file.
The following example shows the basic type collection definition:

code[Franca][
typeCollection ExampleTypeCollection {
	version { major 3 minor 1 }
	
	// put user-defined types and constant definitions here
}
]

As type collections are just a plain collection of user-defined types,
inheritance is not supported for them. All user-defined types inside a
type collection have global visibility. I.e., they can be used for
defining interfaces as well as user-defined types in another type collection.
This is different from the visibility of types that are defined as part of an
interface (see below).  


section:FIDL_Interface[Interface definition]

Each interface in Franca consists of some metadata (e.g., interface name and version number),
the actual interface definition (consisting of attributes, methods and broadcasts), an optional
ref:FIDL_Contracts[contract] specifying the dynamic behavior of the interface and, last but not least,
user-defined ref:FIDL_Types[data types] and ref:FIDL_Constants[constants].
An interface definition might use the user-defined types of another interface definition
only if it inherits (directly or indirectly) from that interface definition.
Thus, the visibility of user-defined types as part of an interface definition is restricted.
This is different from the global visibility of types which are part of a type collection.    

section2:FIDL_Interface_Basic[Basic interface definition]

section3:FIDL_Interface_Basic_Structure[Interface name, version and contents]

The basic interface definition using Franca includes an interface name
and a version number (major/minor scheme).
The name of an interface has to be a single identifier.
The following example gives a blueprint for the structure of an interface definition:

code[Franca][
interface ExampleInterface {
	version { major 5 minor 0 }
	
	// put type definitions and constant definitions here

	// put attributes, methods and broadcasts here
	
	// put optional contract here
}
]

The name of the interface will be scoped relative to the fully qualified name
of the package defined at the beginning of the Franca file.

The elements of an interface can be arranged freely. This allows to provide
a logical grouping of interface elements. The interface contract (if any) should be
the final element of the interface definition.
In previous Franca versions, the order of the elements of an interface
was fixed and thus didn't allow a logical grouping.


section3:FIDL_Interface_Basic_Versioning[Interface versioning and change compatibility]

The specification of a major/minor version number is optional, but is strongly recommended.
Changes in the major number indicate changes which are not backward compatible.
Example use cases for e[incompatible] changes:
ul[
	item[remove attribute, method or broadcast]
	item[remove element from struct or union]
	item[rename an attribute]
	item[rename a method or broadcast, or one of its arguments]
	item[rename a user-defined data-type]
	item[add a contract to an interface which previously didn't have any]
	item[tighten the constraints for the dynamic behavior of an interface (i.e., its contract)]
]
Interface designers should try hard to avoid incompatible changes, or at least provide
periods during which a feature is marked as deprecated before it is removed completely. 

Changes in the minor number indicate changes which are backward compatible.
Example use cases for backward e[compatible] changes:
ul[
	item[add attribute, method or broadcast]
	item[add an argument to a method or broadcast (*)]
	item[add a field to a struct or union (*)]
	item[remove a contract from an interface]
	item[ease restrictions on the dynamic behavior of an interface (i.e., its contract)]
] 

(*) In some target IDLs, adding arguments for methods or broadcast or adding members to
structs might be regarded as incompatible change. It might be hard to map the version numbers
between Franca and those IDLs.


section3:FIDL_Interface_Basic_Inheritance[Interface inheritance]

Franca supports interface e[inheritance] by using the keyword e[extends].
This allows to derive a new interface from an existing one and add
further elements to the base's members. Only single inheritance is allowed for
each interface definition - however, a chain or tree of interfaces can be build. Example:
code[Franca][
interface BaseInterface {
	// ...
}

interface DerivedInterface extends BaseInterface {
	// ...
}
]

ref:InheritanceSemantics[The following table] lists all interface members and
how their semantics is handled with respect to interface inheritance.

table:InheritanceSemantics[
	caption[Franca interface members and their semantics with respect to interface inheritance.]
	tf[
		professional
		tcol[2] tcol[5]
	]
	tr[
		td[e[Interface element]]
		td[e[Inheritance semantics]]
		---
	]
	tr[
		td[type definitions]
		td[All types of the base interface are inherited by the derived interface.
		   Redefining of types is not allowed (i.e., type with same name in 
		   base and derived interface).
		]
	]
	tr[
		td[constant definitions]
		td[All constant definitions of the base interface are inherited by
		   the derived interface.
		   Redefining of constants is not allowed (i.e., constant with same name in 
		   base and derived interface).
		]
	]
	tr[
		td[attributes]
		td[All attributes of the base interface are inherited by the derived interface.
		   Overloading of attributes is not allowed (i.e., attribute with same name in 
		   base and derived interface).
		]
	]
	tr[
		td[methods]
		td[All methods of the base interface are inherited by the derived interface.
		   Methods can be overloaded, either in the same interface or via inheritance.
		   I.e., methods with the same name can be defined as long as the signature
		   of those methods is different. See ref:FIDL_Interface_Method_Overloading
		   for more details on overloading.
		   In versions prior to Franca 0.7.4, overloading of methods was not allowed.
		]
	]
	tr[
		td[broadcasts]
		td[All broadcasts of the base interface are inherited by the derived interface.
		   Broadcasts can be overloaded, either in the same interface or via inheritance.
		   I.e., broadcasts with the same name can be defined as long as the signature
		   of those methods is different. See ref:FIDL_Interface_Broadcast_Overloading
		   for more details on overloading.
		   In versions prior to Franca 0.7.4, overloading of broadcasts was not allowed.
		]
	]
	tr[
		td[contract]
		td[The contract of the base interface is inherited by the derived interface.
		   It is not possible currently to redefine the inherited contract.
		   This will change in a future release of Franca (this will allow extending
		   the contract of its base interface by the derived interface).
		]
	]
]

If the target language doesn't support inheritance for interfaces, the e[extends]-chain
will be transformed into a flat interface definition consisting of all elements of the base
interface(s) and those of the derived interface.


section2:FIDL_Interface_Attribute[Attributes]

An e[attribute] is a property on the provider side, which is defined as part of the interface
with its type and name:

code[Franca][
interface ExampleInterface {
	attribute UInt32 someAttribute
	attribute ExampleArray otherAttribute
	attribute String\[\] arrayAttribute
}
]

Attributes might have primitive types or user-defined types. They also can be defined
as inline, unnamed arrays (e.g., the attribute e[arrayAttribute] in the example above). 

The interface provider holds the data for its attributes and is able to change their values.
The clients of an interface might actively read its attributes' values.
The clients also might register for updates of this attribute and will get change
notifications afterwards. The detailed behavior of an attribute can be specified
by a combination of flags (see details below). 

For target IPC platforms which do not support attributes, code might be generated to add
this support. Typically, a getAttribute method and a registerForUpdate method would be provided.

section3:FIDL_Interface_Attribute_Readonly[Readonly attributes]

By default, clients can read and write the values of attributes. This access can
be restricted by specifying the per-attribute flag e[readonly]. When the flag is given,
the clients of the corresponding interface are not allowed to change the attribute's
value. However, the server might offer some methods which will change the attribute.
Example for the e[readonly]-flag:

code[Franca][
interface ExampleInterface {
	attribute Float throttle
	attribute Float speed readonly
}
]
  
In the example, attribute e[throttle] can be written, while attribute e[speed] can only
by read by the clients.

section3:FIDL_Interface_Attribute_noRead[Write-only attributes]

It is also possible to disallow the read access to the value of an attribute
by specifying the per-attribute flag e[noRead] (available since Franca 0.12.0).
When the flag is given, the clients of the corresponding interface are not allowed to
explicitly read the attribute's value. I.e., code generators will not provide a getter
function for the generated attibute. However, the attribute's value might still
be retrieved using the subscription mechanism as described below.
Example for the e[noRead]-flag:

code[Franca][
interface ExampleInterface {
	attribute UInt32 controlRegister noRead
}
]
  
In the example, attribute e[controlRegister] cannot be explicitly read by the clients.
However, it can be written, and updates might be received using the subscription mechanism.

It is also possible to combine the flags e[noRead] and e[readonly].

code[Franca][
interface ExampleInterface {
	attribute UInt32 countdown noRead readonly
}
]

The combination of both flags might seem non-intuitive at first glance.
Attributes with both flags set cannot be explicitly read or written by clients.
However, clients will still receive updates on attribute value changes.

section3:FIDL_Interface_Attribute_NoSubscriptions[Client subscriptions]

As mentioned above, clients of an interface might register for updates of
an attribute's value. Sometimes it is necessary to specify attributes which do not
support this subscription option. This can be accomplished by adding the
flag e[noSubscriptions] to the attribute's definition.
Example for the e[noSubscriptions]-flag:

code[Franca][
interface ExampleInterface {
	attribute Double temperature readonly noSubscriptions
	attribute Boolean overheated
}
]

The attribute e[temperature] in the example will change often, so that it is better
to disallow subscriptions and use some kind of polling instead. For the boolean
attribute e[overheated], subscriptions are possible (which is really what clients
expect). Note that the e[noSubscriptions] flag has been combined with the flag
e[readonly] in order to disallow changes by the clients, too. 


section2:FIDL_Interface_Method[Methods]

section3:FIDL_Interface_Method_Basic[Basic method syntax]

A e[method] in a Franca interface is called by one of the clients using the interface;
the response will be sent by the server. Therefore, a method definition will contain 
a set of e[in]-arguments and a set of e[out]-arguments, each with own type and name.
Example:

code[Franca][
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}	
	}
}
]

Arguments might have primitive types or user-defined types. Arguments may be also 
specified as unnamed, inline arrays as in the following example:

code[Franca][
interface LetterCount {
	method count {
		in {
			String\[\] words
		}
		out {
			UInt16\[\] counts
		}	
	}
}
]

Argument names must be unique. This also applies across the e[in] and e[out] sections.
Thus, the following example will not be valid:

code[Franca][
	method play {
		// validation error: "Duplicate argument name 'track' used for in and out"
		in { TrackInfo track }
		out { UInt16 track }
	}
] 

section3:FIDL_Interface_Method_RuntimeBehavior[Runtime semantics of method calls]

The runtime behavior of a method call (e.g., blocking vs. non-blocking) is subject to
implementation by the underlying target IPC stack. Thus, it will not be specified as part
of the interface definition in the IDL. This information will be stored in an additional
ref:FrancaConcepts_DeploymentModels[deployment model], instead. 

section3:FIDL_Interface_Method_Errors[Declaration of method errors]

If a problem occurs during execution of the method on server side, the server
might issue an e[error] instead of sending the normal reply with its e[out]-arguments.
This semantics can be defined as in the following example:

code[Franca][
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error {
			DIVISION_BY_ZERO
			OVERFLOW
			UNDERFLOW
		}
	}
}
]

The component providing the e[Calculator] interface will either return a reply
with the e[out]-arguments or reply with an error code as specified by the 
nameless enumeration defined as part of the method specification.


In fact, the syntax above is the same as with the definition of
ref:FIDL_Types_Enum[enumerations]. I.e., optional values and structured comments
can be added to each of the enumerators. Moreover, a reference to a base enumerator
can be added using the keyword e[extends] - this allows inheriting of common
error codes:  

code[Franca][
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error extends GenericErrors {
			DIVISION_BY_ZERO
			OVERFLOW
			UNDERFLOW
		}			
	}

	enumeration GenericErrors {
		INVALID_PARAMATERS
		// ...
	}
}
]


Finally, it is possible to directly reference a separately defined e[enumeration],
which might also be located in a different Franca file. Example:

code[Franca][
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error CalcErrors
	}

	enumeration CalcErrors {
		DIVISION_BY_ZERO
		OVERFLOW
		UNDERFLOW
	}
}
]

section3:FIDL_Interface_Method_FireAndForget[Fire-and-forget methods]

If neither e[out] arguments nor e[error] return codes are specified for
a method, the server will by default send an (empty) reply to its client.
This behavior can be changed by specifying a e[fireAndForget] flag for
the method, which indicates that the server will not respond at all.

Example:
code[Franca][
interface Watchdog {
	method stillAlive fireAndForget {
		in { UInt16 health }
	}
}
]

This can be used to implement lightweight communication patterns.

section3:FIDL_Interface_Method_Overloading[Method overloading]

Franca IDL also allows method overloading, i.e., interfaces with two or more methods
with the same name. This is allowed as long as the method signatures are different,
i.e., the sets of combined e[in]- and e[out]-argument types must be different for each
overloaded method. Note that only the types will be part of the signature, not the
argument names. The following example shows a valid case of overloading:

code[Franca][
interface SomeInterface {
  method callMe {
    in { Boolean b }
  }  

  method callMe {
    in { Boolean b }
    out { String s }
  }  
}]

Note that although the set of e[in]-arguments is identical, the second version of 
method code[Franca][callMe] has an additional e[out]-argument. This is a sufficient
distinction to allow overloading. It is also sufficient to have a difference in 

In Franca contracts and deployment models it is necessary to uniquely reference
single methods. In order to tell apart several overloaded methods with the same name,
the method names can be extended by e[selectors], which are not part of the method name,
but which can be used to discriminate overloaded methods.
This is shown in the following example.

code[Franca][
interface SomeInterface {
  method callMe:a {
    in { Boolean b }
  }  

  method callMe:b {
    in { Boolean b }
    out { String s }
  }  
}]

The selectors for each group of overloaded methods must be unique, which is essential
for their purpose to discriminate the methods which otherwise have an identical name. 

Overloading is also relevant in the context of interface inheritance. For methods
of derived interfaces which overload methods from base interfaces the same rules
apply as described previously. See ref:FIDL_Interface_Basic_Inheritance for more
information on interface inheritance. 
 

section2:FIDL_Interface_Broadcast[Broadcasts]

A e[broadcast] in a Franca interface is called by the server and will be received
by the clients using the interface. A broadcast definition will contain a set of
e[out]-arguments, each with own type and name.
Example:

code[Franca][
interface ExampleInterface {
	broadcast buttonClicked {
		out {
			ButtonId id
			Boolean isLongPress
		}
	}
}
]

Arguments might have primitive types or user-defined types.

section3:FIDL_Interface_Broadcast_Selective[Selective broadcasts]

The default communication pattern for broadcasts is that each server-initiated
broadcast will be send to e[all] connected clients. Optionally, the keyword
e[selective] can be given to indicate that the server might send this broadcast
to one or a subset of the connected clients, depending on application logic
and/or deployment information. Example syntax:

code[Franca][
interface ExampleInterface {
	broadcast stop selective {
		out { Boolean immediately }
	}
}
]

The e[selective] keyword will have the following implications:
ul[
	item[The client must be aware that the server has explicitly
		chosen to send the broadcast to it.]
	item[There might be special e[register()] functions (or similar)
		generated on client side in order to allow clients to decide
		if they want to be receivers of the selective broadcast(s).
		However, this is not mandatory and will usually be
		configured by the deployment model or defined implicitly
		for a given target platform.]
	item[The server will have the opportunity to select among
		its clients when sending the broadcast (e.g., by code
		especially generated for this reason).]
]
 

section3:FIDL_Interface_Broadcast_Overloading[Broadcast overloading]

Also for broadcasts Franca IDL allows overloading. For more details
on restrictions, selectors and inheritance see ref:FIDL_Interface_Method_Overloading.
The following example shows two overloaded broadcasts with selectors.

code[Franca][
	broadcast tsunamiDetected:a {
		out { String location }
	}
	broadcast tsunamiDetected:b {
		out { Double strength }
	}
]


section2:FIDL_Interface_Manages[Interfaces managing interfaces]

In some IPC mechanisms, e.g. D-Bus, we have the concept of linked interfaces.
This usually takes the form that there is a root interface, for example a bluetooth 
service. Then there are many interfaces which are controlled by the root interface.
E.g., each physical bluetooth adapter provides some interface which has to be 
controlled by the root bluetooth service. 

Franca IDL allows to define this association between interfaces using the
keyword code[Franca][manages]. A downstream tool (e.g., a code generator)
could then generate appropriate code for being informed about the "children" in
the implementation of the root.

The following example shows two interfaces which specify the services code[Franca][SomeService]
and code[Franca][OtherService]. The third interface code[Franca][BluetoothMaster] will
control all connections based on one of the two former interface types. This relationship
is modeled by the keyword code[Franca][manages] and a list of managed services.
 
code[Franca][
interface SomeService {
	method getDirectory { }
	method getFile { }
} 

interface OtherService {
	method playMusic { }
} 

interface BluetoothMaster manages SomeService, OtherService {
	attribute UInt16 connectedClients
	method disconnectAll { }
}
]

The code[Franca][manages]-keyword was introduced in Franca 0.8.8.


section:FIDL_Contracts[Contracts]

section2:FIDL_Contracts_Basic[Basic concept of contracts]

For each Franca interface, a e[contract] might be specified which defines the 
dynamic behavior of the interface. Generally, if a contract is part of the interface,
all interactions of clients and providers of this interface have to obey the 
specification in the contract. This is different from behavior specification by
sequences (e.g., MSCs in MOST), which provides a set of allowed sequences, but
in general doesn't require that all legal sequences have been specified.

Note that a contract is a specification of the interaction of a pair
of one client instance and one provider instance. If multiple clients
are connected to one interface on provider side, one instance of the
contract is (conceptually) established for each client. 

In order to specify the dynamic behavior of a Franca interface, 
a e[PSM] (short for: e[Protocol State Machine]) is defined which specifies 
the allowed states e[of the connection] and the allowed transitions between those
states. Example:

code[Franca][
// specification of dynamic behavior on the interface 
contract {
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working
		}
		state working {
			on signal attachOutput -> idle
		}
	}
}
]

The client/server connection specified by this interface can have two states:
ul[
	item[e[idle]: The client is allowed to call the e[setActivePlayer] method.
		No other interaction via the interface is allowed.
		This is the initial state.
		If the client calls the e[setActivePlayer] method, the state will change to e[working].
	]
	item[e[working]: The server is allowed to send the broadcast e[attachOutput].
		No other interaction via the interface is allowed.
		After this broadcast has been sent, the state will change to e[idle]. 
	]
]

section2:FIDL_Contracts_PSM[Protocol state machines]

The e[Protocol State Machines] used for specifying Franca's interface contracts
use e[events] to specify the transitions from one state to another.
Valid events might be:
ul[
	item[e[call]: A method call initiated by the client.]
	item[e[respond]: The server's response for a client's method call.
		Note that e[fireAndForget] methods do not trigger this kind of event
		(see ref:FIDL_Interface_Method_FireAndForget[Fire-and-forget methods]).]
	item[e[signal]: A broadcast sent by the server.]
	item[e[set]: An attribute's value is being changed by a client.]
	item[e[update]: An indication by the server that an attribute's value has been changed.]
]

A transition will be triggered by one out of a set of events. The actual 
transition can be guarded by a boolean condition.

section2:FIDL_Contracts_Actions[Transition actions]

For each transition of a PSM, an optional e[action] can be defined.
The action consists of a set of statements which will be executed each time
the transition is triggered. Note that the execution of these statements
will usually not be implemented by real code on the target system. 
Instead, it will be interpreted during some analysis of the interaction
on the interface. 

All e[actions] are defined in terms of an e[action language], which is
part of Franca IDL. This action language is purposefully small and simple
in order to allow static analysis and interpretation of the actions.

Here is an example which shows the syntax of actions:
code[Franca][
contract {
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working {
				// put action code here
			}	
		}
		state working {
			on signal attachOutput -> idle {
				// put action code here
			}
		}
	}
}
]

The elements of the action language are still subject to development
and will be described in a later version of this document.   


section2:FIDL_Contracts_StateVars[State variables]

A PSM can refer to e[state variables] which have been defined as part
of the contract. The state variables are statically typed.
Any guard or action of a transition can refer to the state variables.
The boolean guards can check the values of either message arguments,
attribute values or state variable values.

The following examples enhances the contract defined above by a state variable
and an action counting the number of e[setActivePlayer] method calls.
The two transitions of state e[working] are guarded; the guards are checking
the value of the state variable. After 100 interactions, the PSM will
enter state e[silence] and will not accept any more events.
The contract specifies an interface which allows a maximum of 100 calls of 
method e[setActicePlayer]. As the e[silence] state doesn't have any outgoing 
transitions, the system will have to be restarted in order to allow further
activities on this interface.
code[Franca][
contract {
	vars {
		UInt32 count;
	}
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working {
				count = count + 1
			}	
		}
		state working {
			on signal attachOutput \[count<100\] -> idle
			on signal attachOutput \[count>=100\] -> silence
		}
		state silence { }
	}
}
]

In a future release of Franca IDL there will be mandatory extensions
for defining the value domains of the state variables (e.g., ranges for 
integer values). This will allow model checking of PSMs. 

section2:FIDL_Contracts_Benefits[Exploiting contract information]

The contract information can be used in a variety of ways:
ul[
	item[Development tools used for the implementation of components could
		use the information to guide the developer through the software design
		process. 
	]
	item[Test code could be generated on client or server side which 
		checks for correct sequences at runtime.
	]
	item[Target traces can be analysed offline by validating sequences against the contract.]
]

The e[contract]-feature in Franca is still under development. However,
by specifying the proper and allowed behavior of interfaces in a consistent way
the value and expressiveness of interface definitions can be increased to a large extent.



section:FIDL_Comments[Comments]

Franca supports two kinds of comments: unstructured and structured comments.

section2:FIDL_CommentsUnstructured[Unstructured comments]

Unstructured comments are usually one-line and multi-line comments as well known
from C, C++ or Java. Examples:

code[Franca][
	// this is a one-line unstructured comment
	typedef TypeOne is UInt8
	
	/* this is a multi-line unstructured comment,
	   it could be used also for one-liners :-)    */
	typedef TypeTwo is Int16
]


section2:FIDL_CommentsStructured[Structured comments]

Structured comments consist of tagged meta-information as known for example from JavaDoc.
Each tag is started with an @-sign. The set of available tags is part of the Franca specification.

code[Franca][
	<** @description : Currently active player. All other players will
	                   reject any requests.
	    @author      : E. Wiggin                                      **>
	attribute tPlayer activePlayer
]

Downstream tools can access the tags and their string content and use them
for analysis and code generation.

All built-in tags are listed in ref:CommentTags together with descriptions.

table:CommentTags[
	caption[List of available tags for structured comments in Franca IDL.]
	tf[
		professional
		tcol[2] tcol[7]
	]
	tr[
		td[e[Tag]]
		td[e[Description]]
		---
	]
	tr[
		td[code[Franca][@description]]
		td[A comment with this tag contains a description of the documented
		   interface or datatype element.
		   Typically, the string content of this tag will be used for generated
		   documentation.]
	]
	tr[
		td[code[Franca][@author]]
		td[This tag specifies the author of the documented element.]
	]
	tr[
		td[code[Franca][@deprecated]]
		td[This tag is used to mark the documented element as deprecated.
		   The string content should point out a better solution which
		   can be used in order to avoid using this element.]
	]
	tr[
		td[code[Franca][@source-uri]]
		td[This tag can be used to point to an URI which specifies some kind
		   kind of source information for this element. E.g., if an interface
		   has been created by transformation from a D-Bus introspection file,
		   the source URI could refer to the original D-Bus XML file.]
	]
	tr[
		td[code[Franca][@source-alias]]
		td[This tag can be used in addition to code[Franca][@source-uri] for
		   specifying source elements for the corresponding Franca element.]
	]
	tr[
		td[code[Franca][@see]]
		td[A comment with this tag specifies a further reading or any other
		   kind of semantic reference.]
	]
	tr[
		td[code[Franca][@experimental]]
		td[An element marked with this tag is not a stable part of the 
		   interface definition.]
	]
	tr[
		td[code[Franca][@details]]
		td[This tag is deprecated, it will be removed in a future version.
		   The code[Franca][@description] tag should be used instead.]
	]
	tr[
		td[code[Franca][@param]]
		td[This tag is deprecated, it will be removed in a future version.
		   Instead, the arguments of methods and broadcasts should be documented using
		   the code[Franca][@description] tag for the corresponding arguments.]
	]
	tr[
		td[code[Franca][@high-volume]]
		td[This tag is deprecated, it will be removed in a future version.
		   Specific information related to performance and QoS aspects should be
		   modeled using Franca deployment models.]
	]
	tr[
		td[code[Franca][@high-frequency]]
		td[This tag is deprecated, it will be removed in a future version.
		   Specific information related to performance and QoS aspects should be
		   modeled using Franca deployment models.]
	]
]
 

section:FIDL_MultipleFiles[Fully qualified names, packages, and multiple files]

section2:FIDL_MultipleFiles_FQN[Fully qualified names]

A e[fully qualified name] (or short: e[FQN]) is a sequence of identifiers (at least one)
separated by dots.


section2:FIDL_MultipleFiles_Package[Package declarations]

Each Franca file starts with a e[package]-declaration (similar to Java). 
This puts all type collections and interfaces defined in that file into
the package. The absolute reference for this top-level element is computed
by concatening the package's FQN and the element's FQN. Example:

code[Franca][
package org.franca.examples
interface ExampleInterface {
	// this interface can be globally accessed by the FQN
	//   org.franca.examples.ExampleInterface
}
]


section2:FIDL_MultipleFiles_Imports[Imports and namespace resolution]

If elements in one Franca file need elements from another file, they can reference
the latter only if a corresponding e[import] statement is provided.
There are two kinds of imports. e[Model imports] will import all visible 
top-level elements in the imported file. However, these elements have to be
referenced with their absolute FQN. 

code[Franca][
package org.franca.examples.demo

// model import
import model "basic_types.fidl"

interface ExampleInterface {
	// ...
}
]


e[Namespace imports] will import all visible elements in the given namespace of the 
imported file. These elements can be referenced with a FQN which is relative to the 
given namespace.
 
code[Franca][
package org.franca.examples.demo

// namespace import
import org.franca.examples.demo.* from "basic_types.fidl"

interface ExampleInterface {
	// ...
}
]


