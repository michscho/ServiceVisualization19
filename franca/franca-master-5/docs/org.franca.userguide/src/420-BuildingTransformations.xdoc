chapter:BuildingTransformations[Building transformations to/from Franca]

One particular sweet spot for Franca is its ability to integrate software systems
by supporting transformations from other interface definition languages to Franca IDL.
This chapter describes some concepts around this topic and details how those
transformations can be designed and implemented.

section:BuildingTransformations_Introduction[Introduction]

Software interfaces which are modeled using some other technology than Franca
can be mapped to Franca by providing a model-to-model transformation. This can be done 
in two directions:

ul[
	item[from Franca IDL to another IDL]
	item[from another IDL to Franca IDL]
] 

A e[Franca connector] is a Java class which contains both transformations for a
given IDL. Usually, the other IDL will be modeled based on some meta-model. 
In many environments an e[ecore]-model of the IDL is available
(which is a meta-model in the format given by the
link[http://www.eclipse.org/modeling/emf/][Eclipse Modeling Framework, short: EMF]).
If the other IDL is modeled using some XML-based format, an XML schema or a 
DTD is available, which can be converted automatically to an e[ecore]-model.

Based on the e[ecore]-model, the transformations can be implemented using
any technology which can access either the models directly or uses the
Java API of the e[ecore]-model as generated by EMF. Options are:

ul[
	item[use plain Java or another JVM-based language]
	item[use link[http://www.xtend-lang.org][Xtend] (maybe mixed with Java),
	     which will be transformed into Java automatically]
	item[use a declarative M2M framework, e.g. ATL]
]

In the following we recommend using link[http://www.xtend-lang.org][Xtend] for this task.
It has several nice features which especially support the implementation of
imperative model-to-model transformations.


section:BuildingTransformations_FrancaToX[Transforming Franca to other models]

section2:BuildingTransformations_FrancaToX_Plain[Plain transformations of Franca IDL]

Implementing a plain transformation from Franca IDL models to other models is very similar to
the task of building a generator for Franca IDL. In both cases, a Franca model has to be 
traversed; the extracted information is used to produce a resulting artifact (either generated
code or another model). See the chapter on ref:BuildingGenerators[Building generators with Franca]
for more insights about this topic.

link[http://www.xtend-lang.org][Xtend] has proven to be a powerful and expressive language for
traversing a model and constructing another model from it. There are a couple of
ref:BuildingGenerators_TraversingFrancaModels_Xtend[features supporting model traversal].
Another Xtend feature especially for constructing models as graphs of objects are
e[create-functions]. These provide a cache mechanism to avoid constructing the identical
object twice. See the Xtend reference documentation for details. An example on how
to use e[create-functions] can be found ref:BuildingTransformations_XToFranca_Plain[below].

Example: The plugin e[org.franca.connectors.dbus] is part of the Franca release. It contains
the transformation from Franca to DBus introspection files implemented in Xtend.
This can serve as an example for implementing this kind of transformation.
You will find it in Xtend file e[Franca2DBusTransformation.xtend] in package
e[org.franca.connectors.dbus].


section2:BuildingTransformations_FrancaToX_WithDeployment[Transforming Franca deployment models]

If a model has to be created from Franca deployment models (including a reference to
an Franca IDL model), two models have to be traversed simultaneously. Again, this is 
a topic which is very similar to generating code from Franca deployment models.

For the Franca IDL model there is the ref:FrancaModelAPI[Franca Model API] which allows
programmatic access to IDL models. This is also the recommend way for building transformations
from Franca IDL.
For ref:DeploymentModels[Franca deployment models], there is also an API generated by the
EMF infrastructure. However, we discourage using this API because deployment models are far more
generic than IDL models and contain many implicit assumptions and logical constraints. 
In order to work with deployment models programmatically, e[PropertyAccessor] classes
should be used.

As this is not specific to building model-to-model transformations, but will be needed
also for building generators and other Franca IDL downstream processing tasks,
please refer to common section 
ref:DeploymentModels_DeploymentAccessSupport[Support for accessing deployment properties]
to get the details of accessing Franca deployment models from your transformation implementation.


section:BuildingTransformations_XToFranca[Transforming other models to Franca]

section2:BuildingTransformations_XToFranca_Plain[Plain transformation to Franca IDL]

The typical structure of a transformation of another model into Franca IDL looks
like the following:

ol[
	item[load the source model from file system (or a different source)]
	item[traverse the source model starting from the root (this is typically a top-down traversal)]
	item[extract information from the source model elements and create a Franca IDL model]
	item[save the resulting Franca IDL model or use it for further processing]
]

During the third step elements of the Franca IDL model have to be created and
filled with data. The Java class e[FrancaFactory] has to be used for element creation.
See section ref:FrancaModelAPIReference_FactoryAndPackage[FrancaFactory and FrancaPackage]
for more information on how to do this.

In the context of an Xtend implementation of a transformation, e[create-functions] can
be used to create the proper objects and initialize them. Here is an example showing 
a create function for ref:FrancaModelAPIReference_FInterface[FInterface].

code[Xtend][
// this function will return an object of type FInterface
def create FrancaFactory::eINSTANCE.createFInterface transform(InterfaceType src) {
	// interface name is just a string and doesn't have to be transformed
	name = src.name
	
	// transform interface methods one-by-one
	methods.addAll(src.method.map \[transformMethod\])

	// transform further elements of 'src' and store them in the new FInterface object
	// ...
	
	// implicit return parameter 'it' (the new FInterface object)
} 
]

e[InterfaceType] is the class corresponding to e[FInterface] from the source model
of the transformation (most likely another IDL). When the e[transform()]-method is
being called, it will first check if the source element has been transformed before.
Only if it hasn't been transformed yet, a new ref:FrancaModelAPIReference_FInterface[FInterface]
object will be created. The implicit variable e[it] has to be used to refer to this object.
In the assignment e[name = src.name] the left-hand side is a property of 
ref:FrancaModelAPIReference_FInterface[FInterface], this is a short-hand for e[it.name].

The second line calls uses e[lambda functions] (another handy Xtend feature) in order
to call e[transformMethod()] for each member of the collection e[src.method] and store
the resulting objects (of type ref:FrancaModelAPIReference_FMethod[FMethod]) into the
list e[it.methods]. This is another pattern typically used in model transformations
implemented with link[http://www.xtend-lang.org][Xtend].

Detailed example: The plugin e[org.franca.connectors.dbus] is part of the Franca release. It contains
the transformation from DBus introspection files to Franca IDL implemented in Xtend.
This can serve as an example for implementing this kind of transformation.
You will find it in Xtend file e[DBus2FrancaTransformation.xtend] in package
e[org.franca.connectors.dbus].


section2:BuildingTransformations_XToFranca_WithDeployment[Creating additional deployment models]

It sometimes is necessary to transform a third-party model into two resulting models:
a Franca IDL model and a corresponding Franca deployment model. The first part of this
transformation has been covered by the previous section. In order to create the deployment
model, the helper class e[DeployModelBuilder] should be used. It provides helper functions
for setting deployment properties according to a given deployment specification.

In Xtend code, the e[DeployModelBuilder] can be imported as a static extension:

code[Xtend][
import static extension org.franca.deploymodel.core.DeployModelBuilder.*
]
 
Here is an Xtend code example showing the basic idea of creating IDL model and
deployment model at the same time (the types of the variables could be omitted
and are here for clarity only):

code[Xtend][
// load deployment model containing specification(s) and get the first one
var fdSpecifications = FDModelHelper::instance.loadModel("deployspec.fdepl")
var FDSpecification fdSpec = fdSpecifications.specifications.get(0)

// create Franca IDL model and deployment model
var FModel fModel = FrancaFactory::eINSTANCE.createFModel
var FDModel fdModel = FDeployFactory::eINSTANCE.createFDModel

// prepare DeployModelBuilder

// transform all interfaces
for(src : sourceModel.interfaces) {
	var FInterface result = src.transform
	
	// create deployment model element and add it to deployment model
	var FDInterface fdInterface = FDeployFactory::eINSTANCE.createFDInterface
	fdModel.deployments.add(fdInterface)
	
	// link deployment interface to IDL interface
	fdInterface.target = result
	
	// check properties in the source model and add them to deployment model
	if (src.checkSomeProperty()) {
		// set a deployment property (this uses DeployModelBuilder)
		fdInterface.setProperty(fdSpec, "SomeProperty", true)
	}	
	// ... check more properties and set them, if necessary 
}
] 


Note that the e[setProperty()] function is defined as part of e[DeployModelBuilder]
and is called for a deployment model element (here: e[fdInterface]). The following
parameters are: the underlying deployment specification (here: e[fdSpec]), the
actual name of the property (here: "SomeProperty"), and the new value for the property.
If the new value for the property is equal to the default as defined in the 
deployment specification, e[DeployModelBuilder] will not set the property. 

See the Javadoc documentation of codeRef[org.franca.deploymodel.core.DeployModelBuilder]
to understand all kinds of functions it offers.

Depending on the complexity of the source model, it might be tedious to create the
Franca IDL model and the deployment model at the same time. The difficult detail
is to set the e[target] attribute for all elements of the deployment model (see
example above).
Xtend e[extension methods] and Google's dependency injection framework might help
here by allowing to separate the Franca IDL model construction from the deployment
model construction (see e[com.google.inject] and the e[@Inject] annotation for
Java and Xtend).

There is no example for this kind of transformation in the Franca release yet.
This will be added in a future version.

